/* automatically generated by rust-bindgen */

pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __FILE_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _G_config_h: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const MQTTCLIENT_PERSISTENCE_DEFAULT: u32 = 0;
pub const MQTTCLIENT_PERSISTENCE_NONE: u32 = 1;
pub const MQTTCLIENT_PERSISTENCE_USER: u32 = 2;
pub const MQTTCLIENT_PERSISTENCE_ERROR: i32 = -2;
pub const MQTTASYNC_SUCCESS: u32 = 0;
pub const MQTTASYNC_FAILURE: i32 = -1;
pub const MQTTASYNC_PERSISTENCE_ERROR: i32 = -2;
pub const MQTTASYNC_DISCONNECTED: i32 = -3;
pub const MQTTASYNC_MAX_MESSAGES_INFLIGHT: i32 = -4;
pub const MQTTASYNC_BAD_UTF8_STRING: i32 = -5;
pub const MQTTASYNC_NULL_PARAMETER: i32 = -6;
pub const MQTTASYNC_TOPICNAME_TRUNCATED: i32 = -7;
pub const MQTTASYNC_BAD_STRUCTURE: i32 = -8;
pub const MQTTASYNC_BAD_QOS: i32 = -9;
pub const MQTTASYNC_NO_MORE_MSGIDS: i32 = -10;
pub const MQTTASYNC_OPERATION_INCOMPLETE: i32 = -11;
pub const MQTTASYNC_MAX_BUFFERED_MESSAGES: i32 = -12;
pub const MQTTASYNC_SSL_NOT_SUPPORTED: i32 = -13;
pub const MQTTASYNC_BAD_PROTOCOL: i32 = -14;
pub const MQTTVERSION_DEFAULT: u32 = 0;
pub const MQTTVERSION_3_1: u32 = 3;
pub const MQTTVERSION_3_1_1: u32 = 4;
pub const MQTT_BAD_SUBSCRIBE: u32 = 128;
pub const MQTT_SSL_VERSION_DEFAULT: u32 = 0;
pub const MQTT_SSL_VERSION_TLS_1_0: u32 = 1;
pub const MQTT_SSL_VERSION_TLS_1_1: u32 = 2;
pub const MQTT_SSL_VERSION_TLS_1_2: u32 = 3;
pub const MQTTASYNC_TRUE: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
/// @brief Initialize the persistent store.
///
/// Either open the existing persistent store for this client ID or create a new
/// one if one doesn't exist. If the persistent store is already open, return
/// without taking any action.
///
/// An application can use the same client identifier to connect to many
/// different servers. The <i>clientid</i> in conjunction with the
/// <i>serverURI</i> uniquely identifies the persistence store required.
///
/// @param handle The address of a pointer to a handle for this persistence
/// implementation. This function must set handle to a valid reference to the
/// persistence following a successful return.
/// The handle pointer is passed as an argument to all the other
/// persistence functions. It may include the context parameter and/or any other
/// data for use by the persistence functions.
/// @param clientID The client identifier for which the persistent store should
/// be opened.
/// @param serverURI The connection string specified when the MQTT client was
/// created (see MQTTClient_create()).
/// @param context A pointer to any data required to initialize the persistent
/// store (see ::MQTTClient_persistence).
/// @return Return 0 if the function completes successfully, otherwise return
/// ::MQTTCLIENT_PERSISTENCE_ERROR.
pub type Persistence_open = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut *mut ::std::os::raw::c_void,
        clientID: *const ::std::os::raw::c_char,
        serverURI: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
/// @brief Close the persistent store referred to by the handle.
///
/// @param handle The handle pointer from a successful call to
/// Persistence_open().
/// @return Return 0 if the function completes successfully, otherwise return
/// ::MQTTCLIENT_PERSISTENCE_ERROR.
pub type Persistence_close = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
/// @brief Put the specified data into the persistent store.
///
/// @param handle The handle pointer from a successful call to
/// Persistence_open().
/// @param key A string used as the key for the data to be put in the store. The
/// key is later used to retrieve data from the store with Persistence_get().
/// @param bufcount The number of buffers to write to the persistence store.
/// @param buffers An array of pointers to the data buffers associated with
/// this <i>key</i>.
/// @param buflens An array of lengths of the data buffers. <i>buflen[n]</i>
/// gives the length of <i>buffer[n]</i>.
/// @return Return 0 if the function completes successfully, otherwise return
/// ::MQTTCLIENT_PERSISTENCE_ERROR.
pub type Persistence_put = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_char,
        bufcount: ::std::os::raw::c_int,
        buffers: *mut *mut ::std::os::raw::c_char,
        buflens: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
/// @brief Retrieve the specified data from the persistent store.
///
/// @param handle The handle pointer from a successful call to
/// Persistence_open().
/// @param key A string that is the key for the data to be retrieved. This is
/// the same key used to save the data to the store with Persistence_put().
/// @param buffer The address of a pointer to a buffer. This function sets the
/// pointer to point at the retrieved data, if successful.
/// @param buflen The address of an int that is set to the length of
/// <i>buffer</i> by this function if successful.
/// @return Return 0 if the function completes successfully, otherwise return
/// ::MQTTCLIENT_PERSISTENCE_ERROR.
pub type Persistence_get = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_char,
        buffer: *mut *mut ::std::os::raw::c_char,
        buflen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
/// @brief Remove the data for the specified key from the store.
///
/// @param handle The handle pointer from a successful call to
/// Persistence_open().
/// @param key A string that is the key for the data to be removed from the
/// store. This is the same key used to save the data to the store with
/// Persistence_put().
/// @return Return 0 if the function completes successfully, otherwise return
/// ::MQTTCLIENT_PERSISTENCE_ERROR.
pub type Persistence_remove = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, key: *mut ::std::os::raw::c_char)
        -> ::std::os::raw::c_int,
>;
/// @brief Returns the keys in this persistent data store.
///
/// @param handle The handle pointer from a successful call to
/// Persistence_open().
/// @param keys The address of a pointer to pointers to strings. Assuming
/// successful execution, this function allocates memory to hold the returned
/// keys (strings used to store the data with Persistence_put()). It also
/// allocates memory to hold an array of pointers to these strings. <i>keys</i>
/// is set to point to the array of pointers to strings.
/// @param nkeys A pointer to the number of keys in this persistent data store.
/// This function sets the number of keys, if successful.
/// @return Return 0 if the function completes successfully, otherwise return
/// ::MQTTCLIENT_PERSISTENCE_ERROR.
pub type Persistence_keys = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        keys: *mut *mut *mut ::std::os::raw::c_char,
        nkeys: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
/// @brief Clears the persistence store, so that it no longer contains any
/// persisted data.
///
/// @param handle The handle pointer from a successful call to
/// Persistence_open().
/// @return Return 0 if the function completes successfully, otherwise return
/// ::MQTTCLIENT_PERSISTENCE_ERROR.
pub type Persistence_clear = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
/// @brief Returns whether any data has been persisted using the specified key.
///
/// @param handle The handle pointer from a successful call to
/// Persistence_open().
/// @param key The string to be tested for existence in the store.
/// @return Return 0 if the key was found in the store, otherwise return
/// ::MQTTCLIENT_PERSISTENCE_ERROR.
pub type Persistence_containskey = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, key: *mut ::std::os::raw::c_char)
        -> ::std::os::raw::c_int,
>;
/// @brief A structure containing the function pointers to a persistence
/// implementation and the context or state that will be shared across all
/// the persistence functions.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTClient_persistence {
    /// A pointer to any data required to initialize the persistent store.
    pub context: *mut ::std::os::raw::c_void,
    /// A function pointer to an implementation of Persistence_open().
    pub popen: Persistence_open,
    /// A function pointer to an implementation of Persistence_close().
    pub pclose: Persistence_close,
    /// A function pointer to an implementation of Persistence_put().
    pub pput: Persistence_put,
    /// A function pointer to an implementation of Persistence_get().
    pub pget: Persistence_get,
    /// A function pointer to an implementation of Persistence_remove().
    pub premove: Persistence_remove,
    /// A function pointer to an implementation of Persistence_keys().
    pub pkeys: Persistence_keys,
    /// A function pointer to an implementation of Persistence_clear().
    pub pclear: Persistence_clear,
    /// A function pointer to an implementation of Persistence_containskey().
    pub pcontainskey: Persistence_containskey,
}
#[test]
fn bindgen_test_layout_MQTTClient_persistence() {
    assert_eq!(
        ::std::mem::size_of::<MQTTClient_persistence>(),
        72usize,
        concat!("Size of: ", stringify!(MQTTClient_persistence))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTClient_persistence>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTClient_persistence))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).popen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(popen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).pclose as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(pclose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).pput as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(pput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).pget as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(pget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).premove as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(premove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).pkeys as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(pkeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).pclear as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(pclear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTClient_persistence>())).pcontainskey as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(pcontainskey)
        )
    );
}
/// Initialization options
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_init_options {
    /// The eyecatcher for this structure.  Must be MQTG.
    pub struct_id: [::std::os::raw::c_char; 4usize],
    /// The version number of this structure.  Must be 0
    pub struct_version: ::std::os::raw::c_int,
    /// 1 = we do openssl init, 0 = leave it to the application
    pub do_openssl_init: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MQTTAsync_init_options() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_init_options>(),
        12usize,
        concat!("Size of: ", stringify!(MQTTAsync_init_options))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_init_options>(),
        4usize,
        concat!("Alignment of ", stringify!(MQTTAsync_init_options))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_init_options>())).struct_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_init_options),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_init_options>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_init_options),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_init_options>())).do_openssl_init as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_init_options),
            "::",
            stringify!(do_openssl_init)
        )
    );
}
extern "C" {
    /// Global init of mqtt library. Call once on program start to set global behaviour.
    /// handle_openssl_init - if mqtt library should handle openssl init (1) or rely on the caller to init it before using mqtt (0)
    pub fn MQTTAsync_global_init(inits: *mut MQTTAsync_init_options);
}
/// A handle representing an MQTT client. A valid client handle is available
/// following a successful call to MQTTAsync_create().
pub type MQTTAsync = *mut ::std::os::raw::c_void;
/// A value representing an MQTT message. A token is returned to the
/// client application when a message is published. The token can then be used to
/// check that the message was successfully delivered to its destination (see
/// MQTTAsync_publish(),
/// MQTTAsync_publishMessage(),
/// MQTTAsync_deliveryComplete(), and
/// MQTTAsync_getPendingTokens()).
pub type MQTTAsync_token = ::std::os::raw::c_int;
/// A structure representing the payload and attributes of an MQTT message. The
/// message topic is not part of this structure (see MQTTAsync_publishMessage(),
/// MQTTAsync_publish(), MQTTAsync_receive(), MQTTAsync_freeMessage()
/// and MQTTAsync_messageArrived()).
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_message {
    /// The eyecatcher for this structure.  must be MQTM.
    pub struct_id: [::std::os::raw::c_char; 4usize],
    /// The version number of this structure.  Must be 0
    pub struct_version: ::std::os::raw::c_int,
    /// The length of the MQTT message payload in bytes.
    pub payloadlen: ::std::os::raw::c_int,
    /// A pointer to the payload of the MQTT message.
    pub payload: *mut ::std::os::raw::c_void,
    /// The quality of service (QoS) assigned to the message.
    /// There are three levels of QoS:
    /// <DL>
    /// <DT><B>QoS0</B></DT>
    /// <DD>Fire and forget - the message may not be delivered</DD>
    /// <DT><B>QoS1</B></DT>
    /// <DD>At least once - the message will be delivered, but may be
    /// delivered more than once in some circumstances.</DD>
    /// <DT><B>QoS2</B></DT>
    /// <DD>Once and one only - the message will be delivered exactly once.</DD>
    /// </DL>
    pub qos: ::std::os::raw::c_int,
    /// The retained flag serves two purposes depending on whether the message
    /// it is associated with is being published or received.
    ///
    /// <b>retained = true</b><br>
    /// For messages being published, a true setting indicates that the MQTT
    /// server should retain a copy of the message. The message will then be
    /// transmitted to new subscribers to a topic that matches the message topic.
    /// For subscribers registering a new subscription, the flag being true
    /// indicates that the received message is not a new one, but one that has
    /// been retained by the MQTT server.
    ///
    /// <b>retained = false</b> <br>
    /// For publishers, this ndicates that this message should not be retained
    /// by the MQTT server. For subscribers, a false setting indicates this is
    /// a normal message, received as a result of it being published to the
    /// server.
    pub retained: ::std::os::raw::c_int,
    /// The dup flag indicates whether or not this message is a duplicate.
    /// It is only meaningful when receiving QoS1 messages. When true, the
    /// client application should take appropriate action to deal with the
    /// duplicate message.
    pub dup: ::std::os::raw::c_int,
    /// The message identifier is normally reserved for internal use by the
    /// MQTT client and server.
    pub msgid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MQTTAsync_message() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_message>(),
        40usize,
        concat!("Size of: ", stringify!(MQTTAsync_message))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_message>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).struct_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_message>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).payloadlen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(payloadlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).payload as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).qos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).retained as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(retained)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).dup as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(dup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).msgid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(msgid)
        )
    );
}
/// This is a callback function. The client application
/// must provide an implementation of this function to enable asynchronous
/// receipt of messages. The function is registered with the client library by
/// passing it as an argument to MQTTAsync_setCallbacks(). It is
/// called by the client library when a new message that matches a client
/// subscription has been received from the server. This function is executed on
/// a separate thread to the one on which the client application is running.
/// @param context A pointer to the <i>context</i> value originally passed to
/// MQTTAsync_setCallbacks(), which contains any application-specific context.
/// @param topicName The topic associated with the received message.
/// @param topicLen The length of the topic if there are one
/// more NULL characters embedded in <i>topicName</i>, otherwise <i>topicLen</i>
/// is 0. If <i>topicLen</i> is 0, the value returned by <i>strlen(topicName)</i>
/// can be trusted. If <i>topicLen</i> is greater than 0, the full topic name
/// can be retrieved by accessing <i>topicName</i> as a byte array of length
/// <i>topicLen</i>.
/// @param message The MQTTAsync_message structure for the received message.
/// This structure contains the message payload and attributes.
/// @return This function must return a boolean value indicating whether or not
/// the message has been safely received by the client application. Returning
/// true indicates that the message has been successfully handled.
/// Returning false indicates that there was a problem. In this
/// case, the client library will reinvoke MQTTAsync_messageArrived() to
/// attempt to deliver the message to the application again.
pub type MQTTAsync_messageArrived = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        topicName: *mut ::std::os::raw::c_char,
        topicLen: ::std::os::raw::c_int,
        message: *mut MQTTAsync_message,
    ) -> ::std::os::raw::c_int,
>;
/// This is a callback function. The client application
/// must provide an implementation of this function to enable asynchronous
/// notification of delivery of messages to the server. The function is
/// registered with the client library by passing it as an argument to MQTTAsync_setCallbacks().
/// It is called by the client library after the client application has
/// published a message to the server. It indicates that the necessary
/// handshaking and acknowledgements for the requested quality of service (see
/// MQTTAsync_message.qos) have been completed. This function is executed on a
/// separate thread to the one on which the client application is running.
/// @param context A pointer to the <i>context</i> value originally passed to
/// MQTTAsync_setCallbacks(), which contains any application-specific context.
/// @param token The ::MQTTAsync_token associated with
/// the published message. Applications can check that all messages have been
/// correctly published by matching the tokens returned from calls to
/// MQTTAsync_send() and MQTTAsync_sendMessage() with the tokens passed
/// to this callback.
pub type MQTTAsync_deliveryComplete = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, token: MQTTAsync_token),
>;
/// This is a callback function. The client application
/// must provide an implementation of this function to enable asynchronous
/// notification of the loss of connection to the server. The function is
/// registered with the client library by passing it as an argument to
/// MQTTAsync_setCallbacks(). It is called by the client library if the client
/// loses its connection to the server. The client application must take
/// appropriate action, such as trying to reconnect or reporting the problem.
/// This function is executed on a separate thread to the one on which the
/// client application is running.
/// @param context A pointer to the <i>context</i> value originally passed to
/// MQTTAsync_setCallbacks(), which contains any application-specific context.
/// @param cause The reason for the disconnection.
/// Currently, <i>cause</i> is always set to NULL.
pub type MQTTAsync_connectionLost = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, cause: *mut ::std::os::raw::c_char),
>;
/// This is a callback function, which will be called when the client
/// library successfully connects.  This is superfluous when the connection
/// is made in response to a MQTTAsync_connect call, because the onSuccess
/// callback can be used.  It is intended for use when automatic reconnect
/// is enabled, so that when a reconnection attempt succeeds in the background,
/// the application is notified and can take any required actions.
/// @param context A pointer to the <i>context</i> value originally passed to
/// MQTTAsync_setCallbacks(), which contains any application-specific context.
/// @param cause The reason for the disconnection.
/// Currently, <i>cause</i> is always set to NULL.
pub type MQTTAsync_connected = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, cause: *mut ::std::os::raw::c_char),
>;
/// The data returned on completion of an unsuccessful API call in the response callback onFailure.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_failureData {
    /// A token identifying the failed request.
    pub token: MQTTAsync_token,
    /// A numeric code identifying the error.
    pub code: ::std::os::raw::c_int,
    /// Optional text explaining the error. Can be NULL.
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_MQTTAsync_failureData() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_failureData>(),
        16usize,
        concat!("Size of: ", stringify!(MQTTAsync_failureData))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_failureData>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_failureData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_failureData>())).token as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_failureData>())).code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_failureData>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData),
            "::",
            stringify!(message)
        )
    );
}
/// The data returned on completion of a successful API call in the response callback onSuccess.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MQTTAsync_successData {
    /// A token identifying the successful request. Can be used to refer to the request later.
    pub token: MQTTAsync_token,
    pub alt: MQTTAsync_successData__bindgen_ty_1,
}
/// A union of the different values that can be returned for subscribe, unsubscribe and publish.
#[repr(C)]
#[derive(Copy, Clone)]
pub union MQTTAsync_successData__bindgen_ty_1 {
    /// For subscribe, the granted QoS of the subscription returned by the server.
    pub qos: ::std::os::raw::c_int,
    /// For subscribeMany, the list of granted QoSs of the subscriptions returned by the server.
    pub qosList: *mut ::std::os::raw::c_int,
    pub pub_: MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1,
    pub connect: MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 6usize],
}
/// For publish, the message being sent to the server.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1 {
    pub message: MQTTAsync_message,
    pub destinationName: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1>())).message
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1>()))
                .destinationName as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(destinationName)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2 {
    pub serverURI: *mut ::std::os::raw::c_char,
    pub MQTTVersion: ::std::os::raw::c_int,
    pub sessionPresent: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2>())).serverURI
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(serverURI)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2>()))
                .MQTTVersion as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(MQTTVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2>()))
                .sessionPresent as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(sessionPresent)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(MQTTAsync_successData__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_successData__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1>())).qos as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1>())).qosList as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1),
            "::",
            stringify!(qosList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1>())).pub_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1),
            "::",
            stringify!(pub_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1>())).connect as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1),
            "::",
            stringify!(connect)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData>(),
        56usize,
        concat!("Size of: ", stringify!(MQTTAsync_successData))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_successData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_successData>())).token as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_successData>())).alt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData),
            "::",
            stringify!(alt)
        )
    );
}
/// This is a callback function. The client application
/// must provide an implementation of this function to enable asynchronous
/// notification of the successful completion of an API call. The function is
/// registered with the client library by passing it as an argument in
/// ::MQTTAsync_responseOptions.
/// @param context A pointer to the <i>context</i> value originally passed to
/// ::MQTTAsync_responseOptions, which contains any application-specific context.
/// @param response Any success data associated with the API completion.
pub type MQTTAsync_onSuccess = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        response: *mut MQTTAsync_successData,
    ),
>;
/// This is a callback function. The client application
/// must provide an implementation of this function to enable asynchronous
/// notification of the unsuccessful completion of an API call. The function is
/// registered with the client library by passing it as an argument in
/// ::MQTTAsync_responseOptions.
/// @param context A pointer to the <i>context</i> value originally passed to
/// ::MQTTAsync_responseOptions, which contains any application-specific context.
/// @param response Any failure data associated with the API completion.
pub type MQTTAsync_onFailure = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        response: *mut MQTTAsync_failureData,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_responseOptions {
    /// The eyecatcher for this structure.  Must be MQTR
    pub struct_id: [::std::os::raw::c_char; 4usize],
    /// The version number of this structure.  Must be 0
    pub struct_version: ::std::os::raw::c_int,
    /// A pointer to a callback function to be called if the API call successfully
    /// completes.  Can be set to NULL, in which case no indication of successful
    /// completion will be received.
    pub onSuccess: MQTTAsync_onSuccess,
    /// A pointer to a callback function to be called if the API call fails.
    /// Can be set to NULL, in which case no indication of unsuccessful
    /// completion will be received.
    pub onFailure: MQTTAsync_onFailure,
    /// A pointer to any application-specific context. The
    /// the <i>context</i> pointer is passed to success or failure callback functions to
    /// provide access to the context information in the callback.
    pub context: *mut ::std::os::raw::c_void,
    /// A token is returned from the call.  It can be used to track
    /// the state of this request, both in the callbacks and in future calls
    /// such as ::MQTTAsync_waitForCompletion.
    pub token: MQTTAsync_token,
}
#[test]
fn bindgen_test_layout_MQTTAsync_responseOptions() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_responseOptions>(),
        40usize,
        concat!("Size of: ", stringify!(MQTTAsync_responseOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_responseOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_responseOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).struct_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).struct_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).onSuccess as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(onSuccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).onFailure as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(onFailure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).context as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).token as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(token)
        )
    );
}
extern "C" {
    /// This function sets the global callback functions for a specific client.
    /// If your client application doesn't use a particular callback, set the
    /// relevant parameter to NULL. Any necessary message acknowledgements and
    /// status communications are handled in the background without any intervention
    /// from the client application.  If you do not set a messageArrived callback
    /// function, you will not be notified of the receipt of any messages as a
    /// result of a subscription.
    ///
    /// <b>Note:</b> The MQTT client must be disconnected when this function is
    /// called.
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @param context A pointer to any application-specific context. The
    /// the <i>context</i> pointer is passed to each of the callback functions to
    /// provide access to the context information in the callback.
    /// @param cl A pointer to an MQTTAsync_connectionLost() callback
    /// function. You can set this to NULL if your application doesn't handle
    /// disconnections.
    /// @param ma A pointer to an MQTTAsync_messageArrived() callback
    /// function.  You can set this to NULL if your application doesn't handle
    /// receipt of messages.
    /// @param dc A pointer to an MQTTAsync_deliveryComplete() callback
    /// function. You can set this to NULL if you do not want to check
    /// for successful delivery.
    /// @return ::MQTTASYNC_SUCCESS if the callbacks were correctly set,
    /// ::MQTTASYNC_FAILURE if an error occurred.
    pub fn MQTTAsync_setCallbacks(
        handle: MQTTAsync,
        context: *mut ::std::os::raw::c_void,
        cl: MQTTAsync_connectionLost,
        ma: MQTTAsync_messageArrived,
        dc: MQTTAsync_deliveryComplete,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Sets the MQTTAsync_connected() callback function for a client.
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @param context A pointer to any application-specific context. The
    /// the <i>context</i> pointer is passed to each of the callback functions to
    /// provide access to the context information in the callback.
    /// @param co A pointer to an MQTTAsync_connected() callback
    /// function.  NULL removes the callback setting.
    /// @return ::MQTTASYNC_SUCCESS if the callbacks were correctly set,
    /// ::MQTTASYNC_FAILURE if an error occurred.
    pub fn MQTTAsync_setConnected(
        handle: MQTTAsync,
        context: *mut ::std::os::raw::c_void,
        co: MQTTAsync_connected,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reconnects a client with the previously used connect options.  Connect
    /// must have previously been called for this to work.
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @return ::MQTTASYNC_SUCCESS if the callbacks were correctly set,
    /// ::MQTTASYNC_FAILURE if an error occurred.
    pub fn MQTTAsync_reconnect(handle: MQTTAsync) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function creates an MQTT client ready for connection to the
    /// specified server and using the specified persistent storage (see
    /// MQTTAsync_persistence). See also MQTTAsync_destroy().
    /// @param handle A pointer to an ::MQTTAsync handle. The handle is
    /// populated with a valid client reference following a successful return from
    /// this function.
    /// @param serverURI A null-terminated string specifying the server to
    /// which the client will connect. It takes the form <i>protocol://host:port</i>.
    /// <i>protocol</i> must be <i>tcp</i> or <i>ssl</i>. For <i>host</i>, you can
    /// specify either an IP address or a host name. For instance, to connect to
    /// a server running on the local machines with the default MQTT port, specify
    /// <i>tcp://localhost:1883</i>.
    /// @param clientId The client identifier passed to the server when the
    /// client connects to it. It is a null-terminated UTF-8 encoded string.
    /// @param persistence_type The type of persistence to be used by the client:
    /// <br>
    /// ::MQTTCLIENT_PERSISTENCE_NONE: Use in-memory persistence. If the device or
    /// system on which the client is running fails or is switched off, the current
    /// state of any in-flight messages is lost and some messages may not be
    /// delivered even at QoS1 and QoS2.
    /// <br>
    /// ::MQTTCLIENT_PERSISTENCE_DEFAULT: Use the default (file system-based)
    /// persistence mechanism. Status about in-flight messages is held in persistent
    /// storage and provides some protection against message loss in the case of
    /// unexpected failure.
    /// <br>
    /// ::MQTTCLIENT_PERSISTENCE_USER: Use an application-specific persistence
    /// implementation. Using this type of persistence gives control of the
    /// persistence mechanism to the application. The application has to implement
    /// the MQTTClient_persistence interface.
    /// @param persistence_context If the application uses
    /// ::MQTTCLIENT_PERSISTENCE_NONE persistence, this argument is unused and should
    /// be set to NULL. For ::MQTTCLIENT_PERSISTENCE_DEFAULT persistence, it
    /// should be set to the location of the persistence directory (if set
    /// to NULL, the persistence directory used is the working directory).
    /// Applications that use ::MQTTCLIENT_PERSISTENCE_USER persistence set this
    /// argument to point to a valid MQTTClient_persistence structure.
    /// @return ::MQTTASYNC_SUCCESS if the client is successfully created, otherwise
    /// an error code is returned.
    pub fn MQTTAsync_create(
        handle: *mut MQTTAsync,
        serverURI: *const ::std::os::raw::c_char,
        clientId: *const ::std::os::raw::c_char,
        persistence_type: ::std::os::raw::c_int,
        persistence_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_createOptions {
    /// The eyecatcher for this structure.  must be MQCO.
    pub struct_id: [::std::os::raw::c_char; 4usize],
    /// The version number of this structure.  Must be 0
    pub struct_version: ::std::os::raw::c_int,
    /// Whether to allow messages to be sent when the client library is not connected.
    pub sendWhileDisconnected: ::std::os::raw::c_int,
    /// the maximum number of messages allowed to be buffered while not connected.
    pub maxBufferedMessages: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MQTTAsync_createOptions() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_createOptions>(),
        16usize,
        concat!("Size of: ", stringify!(MQTTAsync_createOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_createOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(MQTTAsync_createOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).struct_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).sendWhileDisconnected as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(sendWhileDisconnected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).maxBufferedMessages as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(maxBufferedMessages)
        )
    );
}
extern "C" {
    pub fn MQTTAsync_createWithOptions(
        handle: *mut MQTTAsync,
        serverURI: *const ::std::os::raw::c_char,
        clientId: *const ::std::os::raw::c_char,
        persistence_type: ::std::os::raw::c_int,
        persistence_context: *mut ::std::os::raw::c_void,
        options: *mut MQTTAsync_createOptions,
    ) -> ::std::os::raw::c_int;
}
/// MQTTAsync_willOptions defines the MQTT "Last Will and Testament" (LWT) settings for
/// the client. In the event that a client unexpectedly loses its connection to
/// the server, the server publishes the LWT message to the LWT topic on
/// behalf of the client. This allows other clients (subscribed to the LWT topic)
/// to be made aware that the client has disconnected. To enable the LWT
/// function for a specific client, a valid pointer to an MQTTAsync_willOptions
/// structure is passed in the MQTTAsync_connectOptions structure used in the
/// MQTTAsync_connect() call that connects the client to the server. The pointer
/// to MQTTAsync_willOptions can be set to NULL if the LWT function is not
/// required.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_willOptions {
    /// The eyecatcher for this structure.  must be MQTW.
    pub struct_id: [::std::os::raw::c_char; 4usize],
    /// The version number of this structure.  Must be 0 or 1
    /// 0 indicates no binary will message support
    pub struct_version: ::std::os::raw::c_int,
    /// The LWT topic to which the LWT message will be published.
    pub topicName: *const ::std::os::raw::c_char,
    /// The LWT payload.
    pub message: *const ::std::os::raw::c_char,
    /// The retained flag for the LWT message (see MQTTAsync_message.retained).
    pub retained: ::std::os::raw::c_int,
    /// The quality of service setting for the LWT message (see
    /// MQTTAsync_message.qos and @ref qos).
    pub qos: ::std::os::raw::c_int,
    pub payload: MQTTAsync_willOptions__bindgen_ty_1,
}
/// The LWT payload in binary form. This is only checked and used if the message option is NULL
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_willOptions__bindgen_ty_1 {
    /// < binary payload length
    pub len: ::std::os::raw::c_int,
    /// < binary payload data
    pub data: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MQTTAsync_willOptions__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_willOptions__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(MQTTAsync_willOptions__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_willOptions__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_willOptions__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_willOptions__bindgen_ty_1>())).len as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_willOptions__bindgen_ty_1>())).data as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTAsync_willOptions() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_willOptions>(),
        48usize,
        concat!("Size of: ", stringify!(MQTTAsync_willOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_willOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_willOptions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_willOptions>())).struct_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_willOptions>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_willOptions>())).topicName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(topicName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_willOptions>())).message as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_willOptions>())).retained as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(retained)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_willOptions>())).qos as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_willOptions>())).payload as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(payload)
        )
    );
}
/// MQTTAsync_sslProperties defines the settings to establish an SSL/TLS connection using the
/// OpenSSL library. It covers the following scenarios:
/// - Server authentication: The client needs the digital certificate of the server. It is included
/// in a store containting trusted material (also known as "trust store").
/// - Mutual authentication: Both client and server are authenticated during the SSL handshake. In
/// addition to the digital certificate of the server in a trust store, the client will need its own
/// digital certificate and the private key used to sign its digital certificate stored in a "key store".
/// - Anonymous connection: Both client and server do not get authenticated and no credentials are needed
/// to establish an SSL connection. Note that this scenario is not fully secure since it is subject to
/// man-in-the-middle attacks.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_SSLOptions {
    /// The eyecatcher for this structure.  Must be MQTS
    pub struct_id: [::std::os::raw::c_char; 4usize],
    /// The version number of this structure.    Must be 0, or 1 to enable TLS version selection.
    pub struct_version: ::std::os::raw::c_int,
    /// The file in PEM format containing the public digital certificates trusted by the client.
    pub trustStore: *const ::std::os::raw::c_char,
    /// The file in PEM format containing the public certificate chain of the client. It may also include
    /// the client's private key.
    pub keyStore: *const ::std::os::raw::c_char,
    /// If not included in the sslKeyStore, this setting points to the file in PEM format containing
    /// the client's private key.
    pub privateKey: *const ::std::os::raw::c_char,
    /// The password to load the client's privateKey if encrypted.
    pub privateKeyPassword: *const ::std::os::raw::c_char,
    /// The list of cipher suites that the client will present to the server during the SSL handshake. For a
    /// full explanation of the cipher list format, please see the OpenSSL on-line documentation:
    /// http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT
    /// If this setting is ommitted, its default value will be "ALL", that is, all the cipher suites -excluding
    /// those offering no encryption- will be considered.
    /// This setting can be used to set an SSL anonymous connection ("aNULL" string value, for instance).
    pub enabledCipherSuites: *const ::std::os::raw::c_char,
    /// True/False option to enable verification of the server certificate
    pub enableServerCertAuth: ::std::os::raw::c_int,
    /// The SSL/TLS version to use. Specify one of MQTT_SSL_VERSION_DEFAULT (0),
    /// MQTT_SSL_VERSION_TLS_1_0 (1), MQTT_SSL_VERSION_TLS_1_1 (2) or MQTT_SSL_VERSION_TLS_1_2 (3).
    /// Only used if struct_version is >= 1.
    pub sslVersion: ::std::os::raw::c_int,
    /// Whether to carry out post-connect checks, including that a certificate
    /// matches the given host name.
    /// Exists only if struct_version >= 2
    pub verify: ::std::os::raw::c_int,
    /// From the OpenSSL documentation:
    /// If CApath is not NULL, it points to a directory containing CA certificates in PEM format.
    /// Exists only if struct_version >= 2
    pub CApath: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_MQTTAsync_SSLOptions() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_SSLOptions>(),
        72usize,
        concat!("Size of: ", stringify!(MQTTAsync_SSLOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_SSLOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_SSLOptions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).struct_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).trustStore as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(trustStore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).keyStore as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(keyStore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).privateKey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(privateKey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).privateKeyPassword as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(privateKeyPassword)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).enabledCipherSuites as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(enabledCipherSuites)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).enableServerCertAuth as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(enableServerCertAuth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).sslVersion as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(sslVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).verify as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).CApath as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(CApath)
        )
    );
}
/// MQTTAsync_connectOptions defines several settings that control the way the
/// client connects to an MQTT server.  Default values are set in
/// MQTTAsync_connectOptions_initializer.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_connectOptions {
    /// The eyecatcher for this structure.  must be MQTC.
    pub struct_id: [::std::os::raw::c_char; 4usize],
    /// The version number of this structure.  Must be 0, 1, 2, 3 4 or 5.
    /// 0 signifies no SSL options and no serverURIs
    /// 1 signifies no serverURIs
    /// 2 signifies no MQTTVersion
    /// 3 signifies no automatic reconnect options
    /// 4 signifies no binary password option (just string)
    pub struct_version: ::std::os::raw::c_int,
    /// The "keep alive" interval, measured in seconds, defines the maximum time
    /// that should pass without communication between the client and the server
    /// The client will ensure that at least one message travels across the
    /// network within each keep alive period.  In the absence of a data-related
    /// message during the time period, the client sends a very small MQTT
    /// "ping" message, which the server will acknowledge. The keep alive
    /// interval enables the client to detect when the server is no longer
    /// available without having to wait for the long TCP/IP timeout.
    /// Set to 0 if you do not want any keep alive processing.
    pub keepAliveInterval: ::std::os::raw::c_int,
    /// This is a boolean value. The cleansession setting controls the behaviour
    /// of both the client and the server at connection and disconnection time.
    /// The client and server both maintain session state information. This
    /// information is used to ensure "at least once" and "exactly once"
    /// delivery, and "exactly once" receipt of messages. Session state also
    /// includes subscriptions created by an MQTT client. You can choose to
    /// maintain or discard state information between sessions.
    ///
    /// When cleansession is true, the state information is discarded at
    /// connect and disconnect. Setting cleansession to false keeps the state
    /// information. When you connect an MQTT client application with
    /// MQTTAsync_connect(), the client identifies the connection using the
    /// client identifier and the address of the server. The server checks
    /// whether session information for this client
    /// has been saved from a previous connection to the server. If a previous
    /// session still exists, and cleansession=true, then the previous session
    /// information at the client and server is cleared. If cleansession=false,
    /// the previous session is resumed. If no previous session exists, a new
    /// session is started.
    pub cleansession: ::std::os::raw::c_int,
    /// This controls how many messages can be in-flight simultaneously.
    pub maxInflight: ::std::os::raw::c_int,
    /// This is a pointer to an MQTTAsync_willOptions structure. If your
    /// application does not make use of the Last Will and Testament feature,
    /// set this pointer to NULL.
    pub will: *mut MQTTAsync_willOptions,
    /// MQTT servers that support the MQTT v3.1 protocol provide authentication
    /// and authorisation by user name and password. This is the user name
    /// parameter.
    pub username: *const ::std::os::raw::c_char,
    /// MQTT servers that support the MQTT v3.1 protocol provide authentication
    /// and authorisation by user name and password. This is the password
    /// parameter.
    pub password: *const ::std::os::raw::c_char,
    /// The time interval in seconds to allow a connect to complete.
    pub connectTimeout: ::std::os::raw::c_int,
    /// The time interval in seconds
    pub retryInterval: ::std::os::raw::c_int,
    /// This is a pointer to an MQTTAsync_SSLOptions structure. If your
    /// application does not make use of SSL, set this pointer to NULL.
    pub ssl: *mut MQTTAsync_SSLOptions,
    /// A pointer to a callback function to be called if the connect successfully
    /// completes.  Can be set to NULL, in which case no indication of successful
    /// completion will be received.
    pub onSuccess: MQTTAsync_onSuccess,
    /// A pointer to a callback function to be called if the connect fails.
    /// Can be set to NULL, in which case no indication of unsuccessful
    /// completion will be received.
    pub onFailure: MQTTAsync_onFailure,
    /// A pointer to any application-specific context. The
    /// the <i>context</i> pointer is passed to success or failure callback functions to
    /// provide access to the context information in the callback.
    pub context: *mut ::std::os::raw::c_void,
    /// The number of entries in the serverURIs array.
    pub serverURIcount: ::std::os::raw::c_int,
    /// An array of null-terminated strings specifying the servers to
    /// which the client will connect. Each string takes the form <i>protocol://host:port</i>.
    /// <i>protocol</i> must be <i>tcp</i> or <i>ssl</i>. For <i>host</i>, you can
    /// specify either an IP address or a domain name. For instance, to connect to
    /// a server running on the local machines with the default MQTT port, specify
    /// <i>tcp://localhost:1883</i>.
    pub serverURIs: *const *mut ::std::os::raw::c_char,
    /// Sets the version of MQTT to be used on the connect.
    /// MQTTVERSION_DEFAULT (0) = default: start with 3.1.1, and if that fails, fall back to 3.1
    /// MQTTVERSION_3_1 (3) = only try version 3.1
    /// MQTTVERSION_3_1_1 (4) = only try version 3.1.1
    pub MQTTVersion: ::std::os::raw::c_int,
    /// Reconnect automatically in the case of a connection being lost?
    pub automaticReconnect: ::std::os::raw::c_int,
    /// Minimum retry interval in seconds.  Doubled on each failed retry.
    pub minRetryInterval: ::std::os::raw::c_int,
    /// Maximum retry interval in seconds.  The doubling stops here on failed retries.
    pub maxRetryInterval: ::std::os::raw::c_int,
    pub binarypwd: MQTTAsync_connectOptions__bindgen_ty_1,
}
/// Optional binary password.  Only checked and used if the password option is NULL
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_connectOptions__bindgen_ty_1 {
    /// < binary password length
    pub len: ::std::os::raw::c_int,
    /// < binary password data
    pub data: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MQTTAsync_connectOptions__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_connectOptions__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MQTTAsync_connectOptions__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_connectOptions__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_connectOptions__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions__bindgen_ty_1>())).len as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions__bindgen_ty_1>())).data as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTAsync_connectOptions() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_connectOptions>(),
        136usize,
        concat!("Size of: ", stringify!(MQTTAsync_connectOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_connectOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_connectOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).struct_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).keepAliveInterval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(keepAliveInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).cleansession as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(cleansession)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).maxInflight as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(maxInflight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).will as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(will)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).username as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).password as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).connectTimeout as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(connectTimeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).retryInterval as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(retryInterval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).ssl as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(ssl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).onSuccess as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(onSuccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).onFailure as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(onFailure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).context as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).serverURIcount as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(serverURIcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).serverURIs as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(serverURIs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).MQTTVersion as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(MQTTVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).automaticReconnect as *const _
                as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(automaticReconnect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).minRetryInterval as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(minRetryInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).maxRetryInterval as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(maxRetryInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).binarypwd as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(binarypwd)
        )
    );
}
extern "C" {
    /// This function attempts to connect a previously-created client (see
    /// MQTTAsync_create()) to an MQTT server using the specified options. If you
    /// want to enable asynchronous message and status notifications, you must call
    /// MQTTAsync_setCallbacks() prior to MQTTAsync_connect().
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @param options A pointer to a valid MQTTAsync_connectOptions
    /// structure.
    /// @return ::MQTTASYNC_SUCCESS if the client connect request was accepted.
    /// If the client was unable to connect to the server, an error code is
    /// returned via the onFailure callback, if set.
    /// Error codes greater than 0 are returned by the MQTT protocol:<br><br>
    /// <b>1</b>: Connection refused: Unacceptable protocol version<br>
    /// <b>2</b>: Connection refused: Identifier rejected<br>
    /// <b>3</b>: Connection refused: Server unavailable<br>
    /// <b>4</b>: Connection refused: Bad user name or password<br>
    /// <b>5</b>: Connection refused: Not authorized<br>
    /// <b>6-255</b>: Reserved for future use<br>
    pub fn MQTTAsync_connect(
        handle: MQTTAsync,
        options: *const MQTTAsync_connectOptions,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_disconnectOptions {
    /// The eyecatcher for this structure. Must be MQTD.
    pub struct_id: [::std::os::raw::c_char; 4usize],
    /// The version number of this structure.  Must be 0 or 1.  0 signifies no SSL options
    pub struct_version: ::std::os::raw::c_int,
    /// The client delays disconnection for up to this time (in
    /// milliseconds) in order to allow in-flight message transfers to complete.
    pub timeout: ::std::os::raw::c_int,
    /// A pointer to a callback function to be called if the disconnect successfully
    /// completes.  Can be set to NULL, in which case no indication of successful
    /// completion will be received.
    pub onSuccess: MQTTAsync_onSuccess,
    /// A pointer to a callback function to be called if the disconnect fails.
    /// Can be set to NULL, in which case no indication of unsuccessful
    /// completion will be received.
    pub onFailure: MQTTAsync_onFailure,
    /// A pointer to any application-specific context. The
    /// the <i>context</i> pointer is passed to success or failure callback functions to
    /// provide access to the context information in the callback.
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MQTTAsync_disconnectOptions() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_disconnectOptions>(),
        40usize,
        concat!("Size of: ", stringify!(MQTTAsync_disconnectOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_disconnectOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_disconnectOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).struct_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).struct_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).timeout as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).onSuccess as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(onSuccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).onFailure as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(onFailure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).context as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(context)
        )
    );
}
extern "C" {
    /// This function attempts to disconnect the client from the MQTT
    /// server. In order to allow the client time to complete handling of messages
    /// that are in-flight when this function is called, a timeout period is
    /// specified. When the timeout period has expired, the client disconnects even
    /// if there are still outstanding message acknowledgements.
    /// The next time the client connects to the same server, any QoS 1 or 2
    /// messages which have not completed will be retried depending on the
    /// cleansession settings for both the previous and the new connection (see
    /// MQTTAsync_connectOptions.cleansession and MQTTAsync_connect()).
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @param options The client delays disconnection for up to this time (in
    /// milliseconds) in order to allow in-flight message transfers to complete.
    /// @return ::MQTTASYNC_SUCCESS if the client successfully disconnects from
    /// the server. An error code is returned if the client was unable to disconnect
    /// from the server
    pub fn MQTTAsync_disconnect(
        handle: MQTTAsync,
        options: *const MQTTAsync_disconnectOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function allows the client application to test whether or not a
    /// client is currently connected to the MQTT server.
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @return Boolean true if the client is connected, otherwise false.
    pub fn MQTTAsync_isConnected(handle: MQTTAsync) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function attempts to subscribe a client to a single topic, which may
    /// contain wildcards (see @ref wildcard). This call also specifies the
    /// @ref qos requested for the subscription
    /// (see also MQTTAsync_subscribeMany()).
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @param topic The subscription topic, which may include wildcards.
    /// @param qos The requested quality of service for the subscription.
    /// @param response A pointer to a response options structure. Used to set callback functions.
    /// @return ::MQTTASYNC_SUCCESS if the subscription request is successful.
    /// An error code is returned if there was a problem registering the
    /// subscription.
    pub fn MQTTAsync_subscribe(
        handle: MQTTAsync,
        topic: *const ::std::os::raw::c_char,
        qos: ::std::os::raw::c_int,
        response: *mut MQTTAsync_responseOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function attempts to subscribe a client to a list of topics, which may
    /// contain wildcards (see @ref wildcard). This call also specifies the
    /// @ref qos requested for each topic (see also MQTTAsync_subscribe()).
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @param count The number of topics for which the client is requesting
    /// subscriptions.
    /// @param topic An array (of length <i>count</i>) of pointers to
    /// topics, each of which may include wildcards.
    /// @param qos An array (of length <i>count</i>) of @ref qos
    /// values. qos[n] is the requested QoS for topic[n].
    /// @param response A pointer to a response options structure. Used to set callback functions.
    /// @return ::MQTTASYNC_SUCCESS if the subscription request is successful.
    /// An error code is returned if there was a problem registering the
    /// subscriptions.
    pub fn MQTTAsync_subscribeMany(
        handle: MQTTAsync,
        count: ::std::os::raw::c_int,
        topic: *const *mut ::std::os::raw::c_char,
        qos: *mut ::std::os::raw::c_int,
        response: *mut MQTTAsync_responseOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function attempts to remove an existing subscription made by the
    /// specified client.
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @param topic The topic for the subscription to be removed, which may
    /// include wildcards (see @ref wildcard).
    /// @param response A pointer to a response options structure. Used to set callback functions.
    /// @return ::MQTTASYNC_SUCCESS if the subscription is removed.
    /// An error code is returned if there was a problem removing the
    /// subscription.
    pub fn MQTTAsync_unsubscribe(
        handle: MQTTAsync,
        topic: *const ::std::os::raw::c_char,
        response: *mut MQTTAsync_responseOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function attempts to remove existing subscriptions to a list of topics
    /// made by the specified client.
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @param count The number subscriptions to be removed.
    /// @param topic An array (of length <i>count</i>) of pointers to the topics of
    /// the subscriptions to be removed, each of which may include wildcards.
    /// @param response A pointer to a response options structure. Used to set callback functions.
    /// @return ::MQTTASYNC_SUCCESS if the subscriptions are removed.
    /// An error code is returned if there was a problem removing the subscriptions.
    pub fn MQTTAsync_unsubscribeMany(
        handle: MQTTAsync,
        count: ::std::os::raw::c_int,
        topic: *const *mut ::std::os::raw::c_char,
        response: *mut MQTTAsync_responseOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function attempts to publish a message to a given topic (see also
    /// ::MQTTAsync_sendMessage()). An ::MQTTAsync_token is issued when
    /// this function returns successfully. If the client application needs to
    /// test for successful delivery of messages, a callback should be set
    /// (see ::MQTTAsync_onSuccess() and ::MQTTAsync_deliveryComplete()).
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @param destinationName The topic associated with this message.
    /// @param payloadlen The length of the payload in bytes.
    /// @param payload A pointer to the byte array payload of the message.
    /// @param qos The @ref qos of the message.
    /// @param retained The retained flag for the message.
    /// @param response A pointer to an ::MQTTAsync_responseOptions structure. Used to set callback functions.
    /// This is optional and can be set to NULL.
    /// @return ::MQTTASYNC_SUCCESS if the message is accepted for publication.
    /// An error code is returned if there was a problem accepting the message.
    pub fn MQTTAsync_send(
        handle: MQTTAsync,
        destinationName: *const ::std::os::raw::c_char,
        payloadlen: ::std::os::raw::c_int,
        payload: *mut ::std::os::raw::c_void,
        qos: ::std::os::raw::c_int,
        retained: ::std::os::raw::c_int,
        response: *mut MQTTAsync_responseOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function attempts to publish a message to a given topic (see also
    /// MQTTAsync_publish()). An ::MQTTAsync_token is issued when
    /// this function returns successfully. If the client application needs to
    /// test for successful delivery of messages, a callback should be set
    /// (see ::MQTTAsync_onSuccess() and ::MQTTAsync_deliveryComplete()).
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @param destinationName The topic associated with this message.
    /// @param msg A pointer to a valid MQTTAsync_message structure containing
    /// the payload and attributes of the message to be published.
    /// @param response A pointer to an ::MQTTAsync_responseOptions structure. Used to set callback functions.
    /// @return ::MQTTASYNC_SUCCESS if the message is accepted for publication.
    /// An error code is returned if there was a problem accepting the message.
    pub fn MQTTAsync_sendMessage(
        handle: MQTTAsync,
        destinationName: *const ::std::os::raw::c_char,
        msg: *const MQTTAsync_message,
        response: *mut MQTTAsync_responseOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function sets a pointer to an array of tokens for
    /// messages that are currently in-flight (pending completion).
    ///
    /// <b>Important note:</b> The memory used to hold the array of tokens is
    /// malloc()'d in this function. The client application is responsible for
    /// freeing this memory when it is no longer required.
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @param tokens The address of a pointer to an ::MQTTAsync_token.
    /// When the function returns successfully, the pointer is set to point to an
    /// array of tokens representing messages pending completion. The last member of
    /// the array is set to -1 to indicate there are no more tokens. If no tokens
    /// are pending, the pointer is set to NULL.
    /// @return ::MQTTASYNC_SUCCESS if the function returns successfully.
    /// An error code is returned if there was a problem obtaining the list of
    /// pending tokens.
    pub fn MQTTAsync_getPendingTokens(
        handle: MQTTAsync,
        tokens: *mut *mut MQTTAsync_token,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MQTTAsync_isComplete(handle: MQTTAsync, token: MQTTAsync_token)
        -> ::std::os::raw::c_int;
}
extern "C" {
    /// Waits for a request corresponding to a token to complete.
    ///
    /// @param handle A valid client handle from a successful call to
    /// MQTTAsync_create().
    /// @param token An ::MQTTAsync_token associated with a request.
    /// @param timeout the maximum time to wait for completion, in milliseconds
    /// @return ::MQTTASYNC_SUCCESS if the request has been completed in the time allocated,
    /// ::MQTTASYNC_FAILURE if not.
    pub fn MQTTAsync_waitForCompletion(
        handle: MQTTAsync,
        token: MQTTAsync_token,
        timeout: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function frees memory allocated to an MQTT message, including the
    /// additional memory allocated to the message payload. The client application
    /// calls this function when the message has been fully processed. <b>Important
    /// note:</b> This function does not free the memory allocated to a message
    /// topic string. It is the responsibility of the client application to free
    /// this memory using the MQTTAsync_free() library function.
    /// @param msg The address of a pointer to the ::MQTTAsync_message structure
    /// to be freed.
    pub fn MQTTAsync_freeMessage(msg: *mut *mut MQTTAsync_message);
}
extern "C" {
    /// This function frees memory allocated by the MQTT C client library, especially the
    /// topic name. This is needed on Windows when the client libary and application
    /// program have been compiled with different versions of the C compiler.  It is
    /// thus good policy to always use this function when freeing any MQTT C client-
    /// allocated memory.
    /// @param ptr The pointer to the client library storage to be freed.
    pub fn MQTTAsync_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// This function frees the memory allocated to an MQTT client (see
    /// MQTTAsync_create()). It should be called when the client is no longer
    /// required.
    /// @param handle A pointer to the handle referring to the ::MQTTAsync
    /// structure to be freed.
    pub fn MQTTAsync_destroy(handle: *mut MQTTAsync);
}
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_MAXIMUM: MQTTASYNC_TRACE_LEVELS = 1;
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_MEDIUM: MQTTASYNC_TRACE_LEVELS = 2;
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_MINIMUM: MQTTASYNC_TRACE_LEVELS = 3;
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_PROTOCOL: MQTTASYNC_TRACE_LEVELS = 4;
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_ERROR: MQTTASYNC_TRACE_LEVELS = 5;
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_SEVERE: MQTTASYNC_TRACE_LEVELS = 6;
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_FATAL: MQTTASYNC_TRACE_LEVELS = 7;
pub type MQTTASYNC_TRACE_LEVELS = u32;
extern "C" {
    /// This function sets the level of trace information which will be
    /// returned in the trace callback.
    /// @param level the trace level required
    pub fn MQTTAsync_setTraceLevel(level: MQTTASYNC_TRACE_LEVELS);
}
/// This is a callback function prototype which must be implemented if you want
/// to receive trace information.
/// @param level the trace level of the message returned
/// @param meesage the trace message.  This is a pointer to a static buffer which
/// will be overwritten on each call.  You must copy the data if you want to keep
/// it for later.
pub type MQTTAsync_traceCallback = ::std::option::Option<
    unsafe extern "C" fn(level: MQTTASYNC_TRACE_LEVELS, message: *mut ::std::os::raw::c_char),
>;
extern "C" {
    /// This function sets the trace callback if needed.  If set to NULL,
    /// no trace information will be returned.  The default trace level is
    /// MQTTASYNC_TRACE_MINIMUM.
    /// @param callback a pointer to the function which will handle the trace information
    pub fn MQTTAsync_setTraceCallback(callback: MQTTAsync_traceCallback);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_nameValue {
    pub name: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_MQTTAsync_nameValue() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_nameValue>(),
        16usize,
        concat!("Size of: ", stringify!(MQTTAsync_nameValue))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_nameValue>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_nameValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_nameValue>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_nameValue),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_nameValue>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_nameValue),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    /// This function returns version information about the library.
    /// no trace information will be returned.  The default trace level is
    /// MQTTASYNC_TRACE_MINIMUM
    /// @return an array of strings describing the library.  The last entry is a NULL pointer.
    pub fn MQTTAsync_getVersionInfo() -> *mut MQTTAsync_nameValue;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
